#!/usr/bin/env ruby

require 'optparse'
require 'open-uri'
require 'nokogiri'
require 'rdoc'

include Nokogiri

options = {}

parser = OptionParser.new

parser.version = RDoc::VERSION
parser.banner = <<-BANNER
Usage: #{parser.program_name} [options] name

  where name is the name of a page, a class, or a method.

BANNER

parser.on('-h', '--help', 'Print this help.') do
  puts parser
  exit
end
parser.on('-v', '--version', 'Print the version of webri.') do
  puts RDoc::VERSION
  exit
end
parser.on('-r', '--release=STR', 'Sets Ruby release to STR') do |release|
  options[:release] = release
end
parser.parse!

error_message = case ARGV.size
when 0
  'No name given.'
when 1
  nil
else
  'Multiple names given.'
end
raise ArgumentError.new(error_message) if error_message

target_name = ARGV.shift

ReleasesUrl = 'https://docs.ruby-lang.org/en/'
html = URI.open(ReleasesUrl)
@doc = Nokogiri::HTML(html)
link_eles = @doc.xpath("//a")
href_for_release = {}
link_eles.each do |link_ele|
  text = link_ele.text
  next if text.match('outdated')
  release = text.sub('Ruby ', '')
  href = link_ele[:href]
  href_for_release[release] = href
end
release = options[:release]
if release.nil?
  release = href_for_release.keys[1]
end
href = href_for_release[release]
if href.nil?
  releases = href_for_release.keys
  puts "Unrecognized release #{release}; available releases:"
  releases.each_with_index do |release, i|
    puts "  #{i}:  #{release}"
  end
  print "Choose (#{0..releases.size-1}):  "
  release = releases[gets.to_i]
  href = href_for_release[release]
end

toc_url = URI.join(ReleasesUrl, href, 'table_of_contents.html')
html = URI.open(toc_url.to_s)
@doc = Nokogiri::HTML(html)

html = URI.open(toc_url.to_s)
@doc = Nokogiri::HTML(html)

@data_for_name = {}

def make_entries(type)
  xpath = "//li[@class='#{type}']"
  li_eles = @doc.xpath(xpath)
  li_eles.each do |li_ele|
    a_ele = li_ele.xpath('./a').first
    name = a_ele.text
    @data_for_name[name] ||= []
    main_entry = {
      type: type,
      text: a_ele.text,
      name: a_ele.text,
      link: a_ele.attributes['href'].value,
    }
    @data_for_name[name].push(main_entry)
  end
end

make_entries('file')
make_entries('class')
make_entries('module')

# Get the methods.
method_li_eles = @doc.xpath('//li[@class="method"]')
method_li_eles.each do |method_li_ele|
  method_a_ele = method_li_ele.xpath('./a').first
  name = method_a_ele.text
  href = method_a_ele.attributes['href'].value
  @data_for_name[name] ||= []
  method_span_ele = method_li_ele.xpath('./span').first
  parent_name = method_span_ele.text
  @data_for_name[name].push({
                             type: :method,
                             text: name,
                             name: name,
                             link: href,
                             parent_name: parent_name,
                           })
  full_name = parent_name + name
  @data_for_name[name].push({
                             type: :method,
                             text: full_name,
                             name: full_name,
                             link: href,
                             parent_name: parent_name,
                           })
end
# @data_for_name.each_pair do |key, value|
#   p [key, value.size]
# end
p @data_for_name.size

# Select executable for launching web browser.
host_os = RbConfig::CONFIG['host_os']
executable_name = case host_os
                  when /linux|bsd/
                    'xdg-open'
                  when /darwin/
                    'open'
                  when /32$/
                    'start'
                  else
                    message = "Unrecognized host OS: '#{host_os}'."
                    raise RuntimeError.new(message)
                  end

