#!/usr/bin/env ruby

require 'optparse'
require 'open-uri'
require 'nokogiri'
require 'rdoc'

include Nokogiri

options = {}

parser = OptionParser.new

parser.version = RDoc::VERSION
parser.banner = <<-BANNER
Usage: #{parser.program_name} [options] name

  where name is the name of a page, a class, or a method.

BANNER

parser.on('-h', '--help', 'Print this help.') do
  puts parser
  exit
end
parser.on('-v', '--version', 'Print the version of webri.') do
  puts RDoc::VERSION
  exit
end
parser.on('-r', '--release=STR', 'Sets Ruby release to STR') do |release|
  options[:release] = release
end
parser.parse!

error_message = case ARGV.size
when 0
  'No name given.'
when 1
  nil
else
  'Multiple names given.'
end
raise ArgumentError.new(error_message) if error_message

name = ARGV.shift

ReleasesUrl = 'https://docs.ruby-lang.org/en/'
html = URI.open(ReleasesUrl)
doc = Nokogiri::HTML(html)
link_eles = doc.xpath("//a")
href_for_release = {}
link_eles.each do |link_ele|
  text = link_ele.text
  next if text.match('outdated')
  release = text.sub('Ruby ', '')
  href = link_ele[:href]
  href_for_release[release] = href
end
release = options[:release]
if release.nil?
  release = href_for_release.keys[1]
end
href = href_for_release[release]
if href.nil?
  releases = href_for_release.keys
  puts "Unrecognized release #{release}; available releases:"
  releases.each_with_index do |release, i|
    puts "  #{i}:  #{release}"
  end
  print "Choose (#{0..releases.size-1}):  "
  release = releases[gets.to_i]
  href = href_for_release[release]
end

toc_url = URI.join(ReleasesUrl, href, 'table_of_contents.html')
html = URI.open(toc_url.to_s)
doc = Nokogiri::HTML(html)

html = URI.open(toc_url.to_s)
doc = Nokogiri::HTML(html)

data_for_name = {}

# Get the files (free-standing pages).
file_a_eles = doc.xpath('//li[@class="file"]/a')
file_a_eles.each do |file_a_ele|
  name = file_a_ele.text
  data_for_name[name] ||= []
  data_for_name[name].push({
    type: :file,
    text: file_a_ele.text,
    name: file_a_ele.text,
    link: file_a_ele.attributes['href'].value,
  })
end

# Get the classes.
class_a_eles = doc.xpath('//li[@class="class"]/a')
class_a_eles.each do |class_a_ele|
  name = class_a_ele.text
  data_for_name[name] ||= []
  data_for_name[name].push({
                             type: :class,
                             text: class_a_ele.text,
                             name: class_a_ele.text,
                             link: class_a_ele.attributes['href'].value,
                           })
end

# Get the modules.
module_a_eles = doc.xpath('//li[@class="module"]/a')
module_a_eles.each do |module_a_ele|
  name = module_a_ele.text
  data_for_name[name] ||= []
  data_for_name[name].push({
                             type: :module,
                             text: module_a_ele.text,
                             name: module_a_ele.text,
                             link: module_a_ele.attributes['href'].value,
                           })
end

# Get the methods.
method_a_eles = doc.xpath('//li[@class="method"]/a')
method_a_eles.each do |method_a_ele|
  name = method_a_ele.text
  data_for_name[name] ||= []
  data_for_name[name].push({
                             type: :method,
                             text: method_a_ele.text,
                             name: method_a_ele.text,
                             link: method_a_ele.attributes['href'].value,
                           })
end
data_for_name.each_pair do |key, value|
  p [key, value.size]
end

# Get the methods.

# Select executable for launching web browser.
host_os = RbConfig::CONFIG['host_os']
executable_name = case host_os
                  when /linux|bsd/
                    'xdg-open'
                  when /darwin/
                    'open'
                  when /32$/
                    'start'
                  else
                    message = "Unrecognized host OS: '#{host_os}'."
                    raise RuntimeError.new(message)
                  end

